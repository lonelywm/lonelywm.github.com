<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="API,RESTful," />





  <link rel="alternate" href="/atom.xml" title="阿蒙的工作室" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.0" />






<meta name="description" content="文章是转的，有两个版本，先看一个简版的，后面再跟一个全文版的
简版 RESTful协议API与用户的通信协议，总是使用HTTPs协议。
域名应该尽量将API部署在专用域名之下。
https://api.example.com
如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/
版本（Versioning）应该将API的版本号放入URL。">
<meta property="og:type" content="article">
<meta property="og:title" content="好RESTful API的设计原则">
<meta property="og:url" content="http://www.wxameng.com/design-a-RESTful-API/index.html">
<meta property="og:site_name" content="阿蒙的工作室">
<meta property="og:description" content="文章是转的，有两个版本，先看一个简版的，后面再跟一个全文版的
简版 RESTful协议API与用户的通信协议，总是使用HTTPs协议。
域名应该尽量将API部署在专用域名之下。
https://api.example.com
如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/
版本（Versioning）应该将API的版本号放入URL。">
<meta property="og:updated_time" content="2015-12-29T07:35:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="好RESTful API的设计原则">
<meta name="twitter:description" content="文章是转的，有两个版本，先看一个简版的，后面再跟一个全文版的
简版 RESTful协议API与用户的通信协议，总是使用HTTPs协议。
域名应该尽量将API部署在专用域名之下。
https://api.example.com
如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/
版本（Versioning）应该将API的版本号放入URL。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: '[object Object]',
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 好RESTful API的设计原则 | 阿蒙的工作室 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">阿蒙的工作室</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">每天进步一点点</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                好RESTful API的设计原则
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-29T15:01:01+08:00" content="2015-12-29">
              2015-12-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Server/" itemprop="url" rel="index">
                    <span itemprop="name">Server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/design-a-RESTful-API/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="design-a-RESTful-API/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>文章是转的，有两个版本，先看一个简版的，后面再跟一个全文版的</p>
<h2 id="简版_RESTful">简版 RESTful</h2><h3 id="协议">协议</h3><p>API与用户的通信协议，总是使用HTTPs协议。</p>
<h3 id="域名">域名</h3><p>应该尽量将API部署在专用域名之下。</p>
<pre><code><span class="string">https:</span><span class="comment">//api.example.com</span>
</code></pre><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<pre><code><span class="label">https:</span>//example<span class="preprocessor">.org</span>/api/
</code></pre><h3 id="版本（Versioning）">版本（Versioning）</h3><p>应该将API的版本号放入URL。</p>
<pre><code><span class="string">https:</span><span class="comment">//api.example.com/v1/</span>
</code></pre><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>
<h3 id="路径（Endpoint）">路径（Endpoint）</h3><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<pre><code><span class="string">https:</span><span class="comment">//api.example.com/v1/zoos</span>
<span class="string">https:</span><span class="comment">//api.example.com/v1/animals</span>
<span class="string">https:</span><span class="comment">//api.example.com/v1/employees</span>
</code></pre><h3 id="HTTP动词">HTTP动词</h3><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<pre><code>GET（<span class="operator"><span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。
POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。
PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。
<span class="keyword">PATCH</span>（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。
<span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span>
</code></pre><p>还有两个不常用的HTTP动词。</p>
<pre><code><span class="keyword">HEAD</span>：获取资源的元数据。
<span class="keyword"><span class="common">OPTIONS</span></span>：获取信息，关于资源的哪些属性是客户端可以改变的。
</code></pre><p>下面是一些例子。</p>
<pre><code>GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
GET <span class="regexp">/zoos/</span>ID：获取某个指定动物园的信息
PUT <span class="regexp">/zoos/</span>ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH <span class="regexp">/zoos/</span>ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE <span class="regexp">/zoos/</span>ID：删除某个动物园
GET <span class="regexp">/zoos/</span>ID/animals：列出某个指定动物园的所有动物
DELETE <span class="regexp">/zoos/</span>ID<span class="regexp">/animals/</span>ID：删除某个指定动物园的指定动物
</code></pre><h3 id="过滤信息（Filtering）">过滤信息（Filtering）</h3><pre><code>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数。

?limit=<span class="number">10</span>：指定返回记录的数量
?offset=<span class="number">10</span>：指定返回记录的开始位置。
?page=<span class="number">2</span>&amp;per_page=<span class="number">100</span>：指定第几页，以及每页的记录数。
?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=<span class="number">1</span>：指定筛选条件
</code></pre><p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h3 id="状态码（Status_Codes）">状态码（Status Codes）</h3><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<pre><code><span class="number">200</span> OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
<span class="number">201</span> CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
<span class="number">202</span> Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
<span class="number">204</span> NO CONTENT - [DELETE]：用户删除数据成功。
<span class="number">400</span> INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
<span class="number">401</span> Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
<span class="number">403</span> Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。
<span class="number">404</span> NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
<span class="number">406</span> Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
<span class="number">410</span> Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
<span class="number">422</span> Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
<span class="number">500</span> INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
</code></pre><p>状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">这里</a>。</p>
<h3 id="错误处理（Error_handling）">错误处理（Error handling）</h3><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<pre><code><span class="rules">{
    <span class="rule"><span class="attribute">error</span>:<span class="value"> <span class="string">"Invalid API key"</span>
</span></span></span>}
</code></pre><h3 id="返回结果">返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<pre><code>GET /collection：返回资源对象的列表（数组）
GET <span class="regexp">/collection/</span>resource：返回单个资源对象
POST /collection：返回新生成的资源对象
PUT <span class="regexp">/collection/</span>resource：返回完整的资源对象
PATCH <span class="regexp">/collection/</span>resource：返回完整的资源对象
DELETE <span class="regexp">/collection/</span>resource：返回一个空文档
</code></pre><h3 id="Hypermedia_API">Hypermedia API</h3><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<pre><code>{"<span class="attribute">link</span>": <span class="value">{
  "<span class="attribute">rel</span>":   <span class="value"><span class="string">"collection https://www.example.com/zoos"</span></span>,
  "<span class="attribute">href</span>":  <span class="value"><span class="string">"https://api.example.com/zoos"</span></span>,
  "<span class="attribute">title</span>": <span class="value"><span class="string">"List of zoos"</span></span>,
  "<span class="attribute">type</span>":  <span class="value"><span class="string">"application/vnd.yourformat+json"</span>
</span>}</span>}
</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>Hypermedia API的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank" rel="external">api.github.com</a>会得到一个所有可用API的网址列表。</p>
<pre><code>{
  <span class="string">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,
  <span class="string">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,
  <span class="comment">// ...</span>
}
</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="api.github.com/user">api.github.com/user</a>，然后就得到了下面结果。</p>
<pre><code>{
  "<span class="attribute">message</span>": <span class="value"><span class="string">"Requires authentication"</span></span>,
  "<span class="attribute">documentation_url</span>": <span class="value"><span class="string">"https://developer.github.com/v3"</span>
</span>}
</code></pre><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<p>说在前面，这篇文章是无意中发现的，因为感觉写的很好，所以翻译了一下。由于英文水平有限，难免有出错的地方，请看官理解一下。翻译和校正文章花了我大约2周的业余时间，如有人愿意转载请注明出处，谢谢^_^</p>
<h3 id="其他">其他</h3><p>API的身份认证应该使用OAuth 2.0框架。</p>
<p>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<h2 id="全文版_RESTful">全文版 RESTful</h2><p>Principles of good RESTful API Design<br>好RESTful API的设计原则</p>
<p>Good API design is hard! An API represents a contract between you and those who Consume your data. Breaking this contract will result in many angry emails, and a slew of sad users with mobile apps which no longer work. Documentation is half the battle, and it is very difficult to find programmer who also likes to write.</p>
<p>Building an API is one of the most important things you can do to increase the value of your service. By having an API, your service / core application has the potential to become a platform from which other services grow. Look at the current huge tech companies: Facebook, Twitter, Google, GitHub, Amazon, Netflix… None of them would be nearly as big as they are today if they hadn’t opened up their data via API. In fact, an entire industry exists with the sole purpose of consuming data provided by said platforms.</p>
<p><strong>The easier your API is to consume, the more people that will consume it.</strong></p>
<p>The principles of this document, if followed closely when designing your API, will ensure that Consumers of your API will be able to understand what is going on, and should drastically reduce the number of confused and/or angry emails you receive. I’ve organized everything into topics, which don’t necessarily need to be read in order.</p>
<p>做出一个好的API设计很难。API表达的是你的数据和你的数据使用者之间的契约。打破这个契约将会招致很多愤怒的邮件，和一大堆伤心的用户-因为他们手机上的App不工作了。而文档化只能达到一半的效果，并且也很难找到一个愿意写文档的程序员。</p>
<p>你所能做的最重要一件事来提高服务的价值就是创建一个API。因为随着其他服务的成长，有这样一个API会使你的服务或者核心应用将有机会变成一个平台。环顾一下现有的这些大公司：Facebook，Twitter，Google， Github，Amazon，Netflix等。如果当时他们没有通过API来开放数据的话，也不可能成长到如今的规模。事实上，整个行业存在的唯一目的就是消费所谓平台上的数据。</p>
<p><strong>你的API越容易使用，那么就会有越多的人去用它</strong></p>
<p>本文提到的这些原则，如果你的API能严格按照这些原则来设计，使用者就可以知道它接下来要做什么，并且能减少大量不必要的疑惑或者是愤怒的邮件。我已经把所有内容都整理到不同的主题里了，你无需按顺序去阅读它。</p>
<h2 id="Definitions">Definitions</h2><p>定义</p>
<p>Here’s a few of the important terms I will use throughout the course of this document:</p>
<p>Resource: A single instance of an object. For example, an animal.<br>Collection: A collection of homogeneous objects. For example, animals.<br>HTTP: A protocol for communicating over a network.<br>Consumer: A client computer application capable of making HTTP requests.<br>Third Party Developer: A developer not a part of your project but who wishes to consume your data.<br>Server: An HTTP server/application accessible from a Consumer over a network.<br>Endpoint: An API URL on a Server which represents either a Resource or an entire Collection.<br>Idempotent: Side-effect free, can happen multiple times without penalty.<br>URL Segment: A slash-separated piece of information in the URL.<br>这里有一些非常重要的术语，我将在本文里面一直用到它们：</p>
<p>资源：一个对象的单独实例，如一只动物<br>集合：一群同种对象，如动物<br>HTTP：跨网络的通信协议<br>客户端：可以创建HTTP请求的客户端应用程序<br>第三方开发者：这个开发者不属于你的项目但是有想使用你的数据<br>服务器：一个HTTP服务器或者应用程序，客户端可以跨网络访问它<br>端点：这个API在服务器上的URL用于表达一个资源或者一个集合<br>幂等：无边际效应，多次操作得到相同的结果<br>URL段：在URL里面已斜杠分隔的内容</p>
<h2 id="Data_Design_and_Abstraction">Data Design and Abstraction</h2><p>数据设计与抽象</p>
<p>Planning how your API will look begins earlier than you’d think; first you need to decide how your data will be designed and how your core service / application will work. If you’re doing API First Development this should be easy. If you’re attaching an API to an existing project, you may need to provide more abstraction.</p>
<p>Occasionally, a Collection can represent a database table, and a Resource can represent a row within that table. However, this is not the usual case. In fact, your API should abstract away as much of your data and business logic as possible. It is very important that you don’t overwhelm Third-Party Developers with any complex application data, if you do they won’t want to use your API.</p>
<p>There are also many parts of your service which you SHOULD NOT expose via API at all. A common example is that many APIs will not allow third parties to create users.</p>
<p>规划好你的API的外观要先于开发它实际的功能。首先你要知道数据该如何设计和核心服务/应用程序会如何工作。如果你纯粹新开发一个API，这样会比较容易一些。但如果你是往已有的项目中增加API，你可能需要提供更多的抽象。</p>
<p>有时候一个集合可以表达一个数据库表，而一个资源可以表达成里面的一行记录，但是这并不是常态。事实上，你的API应该尽可能通过抽象来分离数据与业务逻辑。这点非常重要，只有这样做你才不会打击到那些拥有复杂业务的第三方开发者，否则他们是不会使用你的API的。</p>
<p>当然你的服务可能很多部分是不应该通过API暴露出去的。比较常见的例子就是很多API是不允许第三方来创建用户的。</p>
<h2 id="Verbs">Verbs</h2><p>动词</p>
<p>Surely you know about GET and POST requests. These are the two most commonly requests used when your browser visits different webpages. The term POST is so popular that it has even invaded common language, where people who know nothing about how the Internet works do know they can “post” something on a friends Facebook wall.</p>
<p>There are four and a half very important HTTP verbs that you need to know about. I say “and a half”, because the PATCH verb is very similar to the PUT verb, and two two are often combined by many an API developer. Here are the verbs, and next to them are their associated database call (I’m assuming most people reading this know more about writing to a database than designing an API).</p>
<ul>
<li>GET (SELECT): Retrieve a specific Resource from the Server, or a listing of Resources.</li>
<li>POST (CREATE): Create a new Resource on the Server.</li>
<li>PUT (UPDATE): Update a Resource on the Server, providing the entire Resource.</li>
<li>PATCH (UPDATE): Update a Resource on the Server, providing only changed attributes.</li>
<li><p>DELETE (DELETE): Remove a Resource from the Server.<br>Here are two lesser known HTTP verbs:</p>
</li>
<li><p>HEAD – Retrieve meta data about a Resource, such as a hash of the data or when it was last updated.</p>
</li>
<li>OPTIONS – Retrieve information about what the Consumer is allowed to do with the Resource.<br>A good RESTful API will make use of the four and a half HTTP verbs for allowing third parties to interact with its data, and will never include actions / verbs as URL segments.</li>
</ul>
<p>Typically, GET requests can be cached (and often are!) Browsers, for example, will cache GET requests (depending on cache headers), and will go as far as prompt the user if they attempt to POST for a second time. A HEAD request is basically a GET without the response body, and can be cached as well.</p>
<p>显然你了解GET和POST请求。当你用浏览器去访问不同页面的时候，这两个是最常见的请求。POST术语如此流行以至于开始侵扰通俗用语。即使是那些不知道互联网如何工作的人们也能“post”一些东西到朋友的Facebook墙上。</p>
<p>这里至少有四个半非常重要的HTTP动词需要你知道。我之所以说“半个”的意思是PATCH这个动词非常类似于PUT，并且它们俩也常常被开发者绑定到同一个API上。</p>
<ul>
<li>GET (选择)：从服务器上获取一个具体的资源或者一个资源列表。</li>
<li>POST （创建）： 在服务器上创建一个新的资源。</li>
<li>PUT （更新）：以整体的方式更新服务器上的一个资源。</li>
<li>PATCH （更新）：只更新服务器上一个资源的一个属性。</li>
<li><p>DELETE （删除）：删除服务器上的一个资源。<br>还有两个不常用的HTTP动词：</p>
</li>
<li><p>HEAD ： 获取一个资源的元数据，如数据的哈希值或最后的更新时间。</p>
</li>
<li>OPTIONS：获取客户端能对资源做什么操作的信息。</li>
<li>一个好的RESTful API只允许第三方调用者使用这四个半HTTP动词进行数据交互，并且在URL段里面不出现任何其他的动词。</li>
</ul>
<p>一般来说，GET请求可以被浏览器缓存（通常也是这样的）。例如，缓存请求头用于第二次用户的POST请求。HEAD请求是基于一个无响应体的GET请求，并且也可以被缓存的。</p>
<h2 id="Versioning">Versioning</h2><p>版本化</p>
<p>No matter what you are building, no matter how much planning you do beforehand, your core application is going to change, your data relationships will change, attributes will invariably be added and removed from your Resources. This is just how software development works, and is especially true if your project is alive and used by many people (which is likely the case if you’re building an API).</p>
<p>Remember than an API is a published contract between a Server and a Consumer. If you make changes to the Servers API and these changes break backwards compatibility, you will break things for your Consumer and they will resent you for it. Do it enough, and they will leave. To ensure your application evolves AND you keep your Consumers happy, you need to occasionally introduce new versions of the API while still allowing old versions to be accessible.</p>
<p>As a side note, if you are simply ADDING new features to your API, such as new attributes on a Resource (which are not required and the Resource will function without), or if you are ADDING new Endpoints, you do not need to increment your API version number since these changes do not break backwards compatibility. You will want to update your API Documentation (your Contract), of course.</p>
<p>Over time you can deprecate old versions of the API. To deprecate a feature doesn’t mean to shut if off or diminish the quality of it, but to tell Consumers of your API that the older version will be removed on a specific date and that they should upgrade to a newer version.</p>
<p>A good RESTful API will keep track of the version in the URL. The other most common solution is to put a version number in a request header, but after working with many different Third Party Developers, I can tell you that adding headers is no where near as easy as adding a URL Segment.</p>
<p>无论你正在构建什么，无论你在入手前做了多少计划，你核心的应用总会发生变化，数据关系也会变化，资源上的属性也会被增加或删除。只要你的项目还活着，并且有大量的用户在用，这种情况总是会发生。</p>
<p>请谨记一点，API是服务器与客户端之间的一个公共契约。如果你对服务器上的API做了一个更改，并且这些更改无法向后兼容，那么你就打破了这个契约，客户端又会要求你重新支持它。为了避免这样的事情，你既要确保应用程序逐步的演变，又要让客户端满意。那么你必须在引入新版本API的同时保持旧版本API仍然可用。</p>
<p>注：如果你只是简单的增加一个新的特性到API上，如资源上的一个新属性或者增加一个新的端点，你不需要增加API的版本。因为这些并不会造成向后兼容性的问题，你只需要修改文档即可。</p>
<p>随着时间的推移，你可能声明不再支持某些旧版本的API。申明不支持一个特性并不意味着关闭或者破坏它。而是告诉客户端旧版本的API将在某个特定的时间被删除，并且建议他们使用新版本的API。</p>
<p> 一个好的RESTful API会在URL中包含版本信息。另一种比较常见的方案是在请求头里面保持版本信息。但是跟很多不同的第三方开发者一起工作后，我可以很明确的告诉你，在请求头里面包含版本信息远没有放在URL里面来的容易。</p>
<h2 id="Analytics">Analytics</h2><p>分析</p>
<p>Keep track of the version/endpoints of your API being used by Consumers. This can be as simple as incrementing an integer in a database each time a request is made. There are many reasons that keeping track of API Analytics is a good idea, for example, the most commonly used API calls should be made efficient.</p>
<p>For the purposes of building an API which Third Party Developers will love, the most important thing is that when you do deprecate a version of your API, you can actually contact developers using deprecated API features. This is the perfect way to remind them to upgrade before you kill the old API version.</p>
<p>The process of Third Party Developer notification can be automated, e.g. mail the developer every time 10,000 requests to a deprecated feature are made.</p>
<p>所谓API分析就是持续跟踪那些正为人使用的API的版本和端点信息。而这可能就跟每次请求都往数据库增加一个整数那样简单。有很多的原因显示API跟踪分析是一个好主意，例如，对那些使用最广泛的API来说效率是最重要的。</p>
<p>第三方开发者通常会关注API的构建目的，其中最重要的一个目的是你决定什么时候不再支持某个版本。你需要明确的告知开发者他们正在使用那些即将被移除的API特性。这是一个很好的方式在你准备删除旧的API之前去提醒他们进行升级。</p>
<p>当然第三方开发者的通知流程可以以某种条件被自动触发，例如每当一个过时的特性上发生10000次请求时就发邮件通知开发者。</p>
<h2 id="API_Root_URL">API Root URL</h2><p>API根URL</p>
<p>The root location of your API is important, believe it or not. When a developer (read as code archaeologist) inherits an old project using your API and needs to build new features, they may not know about your service at all. Perhaps all they know is a list of URLs which the Consumer calls out to. It’s important that the root entry point into your API is as simple as possible, as a long complex URL will appear daunting and can turn developers away.</p>
<p>Here are two common URL Roots:</p>
<ul>
<li><a href="https://example.org/api/v1/*" target="_blank" rel="external">https://example.org/api/v1/*</a></li>
<li><a href="https://api.example.com/v1/*" target="_blank" rel="external">https://api.example.com/v1/*</a></li>
</ul>
<p>If your application is huge, or you anticipate it becoming huge, putting the API on its own subdomain (e.g. api.) is a good choice. This can allow for some more flexible scalability down the road.</p>
<ul>
<li><a href="https://example.org/api/v1/*" target="_blank" rel="external">https://example.org/api/v1/*</a></li>
<li><a href="https://api.example.com/v1/*" target="_blank" rel="external">https://api.example.com/v1/*</a></li>
</ul>
<p>If you anticipate your API will never grow to be that large, or you want a much simpler application setup (e.g. you want to host the website AND API from the same framework), placing your API beneath a URL segment at the root of the domain (e.g. /api/) works as well.</p>
<p>It’s a good idea to have content at the root of your API. Hitting the root of GitHub’s API returns a listing of endpoints, for example. Personally, I’m a fan of having the root URL give information which a lost developer would find useful, e.g., how to get to the developer documentation for the API.</p>
<p>Also, notice the HTTPS prefix. As a good RESTful API, you must host your API behind HTTPS.</p>
<p>无论你信不信，API的根地址很重要。当一个开发者接手了一个旧项目（如进行代码考古时）。而这个项目正在使用你的API，同时开发者还想构建一个新的特性，但他们完全不知道你的服务。幸运的是他们知道客户端对外调用的那些URL列表。让你的API根入口点保持尽可能的简单是很重要的，因为开发者很可能一看到那些冗长而又复杂的URL就转身而走。</p>
<p>这里有两个常见的URL根例子：</p>
<ul>
<li><a href="https://example.org/api/v1/*" target="_blank" rel="external">https://example.org/api/v1/*</a></li>
<li><a href="https://api.example.com/v1/*" target="_blank" rel="external">https://api.example.com/v1/*</a></li>
</ul>
<p>如果你的应用很庞大或者你预期它将会变的很庞大，那么将API放到子域下通常是一个好选择。这种做法可以保持某些规模化上的灵活性。</p>
<p>但如果你觉得你的API不会变的很庞大，或是你只是想让应用安装更简单些（如你想用相同的框架来支持站点和API），将你的API放到根域名下也是可以的。</p>
<p>让API根拥有一些内容通常也是个好主意。Github的API根就是一个典型的例子。从个人角度来说我是一个通过根URL发布信息的粉丝，这对很多人来说是有用的，例如如何获取API相关的开发文档。</p>
<p>同样也请注意HTTPS前缀，一个好的RESTful API总是基于HTTPS来发布的。</p>
<h2 id="Endpoints">Endpoints</h2><p>端点</p>
<p>An Endpoint is a URL wi个thin your API which points to a specific Resource or a Collection of Resources.</p>
<p>If you were building a fictional API to represent several different Zoo’s, each containing many Animals (with an animal belonging to exactly one Zoo), employees (who can work at multiple zoos) and keeping track of the species of each animal, you might have the following endpoints:</p>
<ul>
<li><a href="https://api.example.com/v1/zoos" target="_blank" rel="external">https://api.example.com/v1/zoos</a></li>
<li><a href="https://api.example.com/v1/animals" target="_blank" rel="external">https://api.example.com/v1/animals</a></li>
<li><a href="https://api.example.com/v1/animal_types" target="_blank" rel="external">https://api.example.com/v1/animal_types</a></li>
<li><a href="https://api.example.com/v1/employees" target="_blank" rel="external">https://api.example.com/v1/employees</a></li>
</ul>
<p>When referring to what each endpoint can do, you’ll want to list valid HTTP Verb and Endpoint combinations. For example, here’s a semi-comprehensive list of actions one can perform with our fictional API. Notice that I’ve preceded each endpoint with the HTTP Verb, as this is the same notation used within an HTTP Request header.</p>
<ul>
<li>GET /zoos: List all Zoos (ID and Name, not too much detail)</li>
<li>POST /zoos: Create a new Zoo</li>
<li>GET /zoos/ZID: Retrieve an entire Zoo object</li>
<li>PUT /zoos/ZID: Update a Zoo (entire object)</li>
<li>PATCH /zoos/ZID: Update a Zoo (partial object)</li>
<li>DELETE /zoos/ZID: Delete a Zoo</li>
<li>GET /zoos/ZID/animals: Retrieve a listing of Animals (ID and Name).</li>
<li>GET /animals: List all Animals (ID and Name).</li>
<li>POST /animals: Create a new Animal</li>
<li>GET /animals/AID: Retrieve an Animal object</li>
<li>PUT /animals/AID: Update an Animal (entire object)</li>
<li>PATCH /animals/AID: Update an Animal (partial object)</li>
<li>GET /animal_types: Retrieve a listing (ID and Name) of all Animal Types</li>
<li>GET /animal_types/ATID: Retrieve an entire Animal Type object</li>
<li>GET /employees: Retrieve an entire list of Employees</li>
<li>GET /employees/EID: Retreive a specific Employee</li>
<li>GET /zoos/ZID/employees: Retrieve a listing of Employees (ID and Name) who work at this Zoo</li>
<li>POST /employees: Create a new Employee</li>
<li>POST /zoos/ZID/employees: Hire an Employee at a specific Zoo</li>
<li>DELETE /zoos/ZID/employees/EID: Fire an Employee from a specific Zoo</li>
</ul>
<p>In the above list, ZID means Zoo ID, AID means Animal ID, EID means Employee ID, and ATID means Animal Type ID. Having a key in your documentation for whatever convention you choose is a good idea.</p>
<p>I’ve left out the common API URL prefix in the above examples for brevity. While this can be fine during communications, in your actual API documentation, you should always display the full URL to each endpoint (e.g. GET <a href="http://api.example.com/v1/animal_type/ATID" target="_blank" rel="external">http://api.example.com/v1/animal_type/ATID</a>).</p>
<p>Notice how the relationships between data is displayed, specifically the many to many relationships between employees and zoos. By adding an additional URL segment, one can perform more specific interactions. Of course there is no HTTP verb for “FIRE”-ing an employee, but by performing a DELETE on an Employee located within a Zoo, we’re able to achieve the same effect.</p>
<p>一个端点就是指向特定资源或资源集合的URL。</p>
<p>如果你正在构建一个虚构的API来展现几个不同的动物园，每一个动物园又包含很多动物，员工和每个动物的物种，你可能会有如下的端点信息：</p>
<ul>
<li><a href="https://api.example.com/v1/zoos" target="_blank" rel="external">https://api.example.com/v1/zoos</a></li>
<li><a href="https://api.example.com/v1/animals" target="_blank" rel="external">https://api.example.com/v1/animals</a></li>
<li><a href="https://api.example.com/v1/animal_types" target="_blank" rel="external">https://api.example.com/v1/animal_types</a></li>
<li><a href="https://api.example.com/v1/employees" target="_blank" rel="external">https://api.example.com/v1/employees</a></li>
</ul>
<p>针对每一个端点来说，你可能想列出所有可行的HTTP动词和端点的组合。如下所示，请注意我把HTTP动词都放在了虚构的API之前，正如将同样的注解放在每一个HTTP请求头里一样。（下面的URL就不翻译了，我觉得没啥必要翻^_^）</p>
<ul>
<li>GET /zoos: List all Zoos (ID and Name, not too much detail)</li>
<li>POST /zoos: Create a new Zoo</li>
<li>GET /zoos/ZID: Retrieve an entire Zoo object</li>
<li>PUT /zoos/ZID: Update a Zoo (entire object)</li>
<li>PATCH /zoos/ZID: Update a Zoo (partial object)</li>
<li>DELETE /zoos/ZID: Delete a Zoo</li>
<li>GET /zoos/ZID/animals: Retrieve a listing of Animals (ID and Name).</li>
<li>GET /animals: List all Animals (ID and Name).</li>
<li>POST /animals: Create a new Animal</li>
<li>GET /animals/AID: Retrieve an Animal object</li>
<li>PUT /animals/AID: Update an Animal (entire object)</li>
<li>PATCH /animals/AID: Update an Animal (partial object)</li>
<li>GET /animal_types: Retrieve a listing (ID and Name) of all Animal Types</li>
<li>GET /animal_types/ATID: Retrieve an entire Animal Type object</li>
<li>GET /employees: Retrieve an entire list of Employees</li>
<li>GET /employees/EID: Retreive a specific Employee</li>
<li>GET /zoos/ZID/employees: Retrieve a listing of Employees (ID and Name) who work at this Zoo</li>
<li>POST /employees: Create a new Employee</li>
<li>POST /zoos/ZID/employees: Hire an Employee at a specific Zoo</li>
<li>DELETE /zoos/ZID/employees/EID: Fire an Employee from a specific Zoo</li>
</ul>
<p>在上面的列表里，ZID表示动物园的ID， AID表示动物的ID，EID表示雇员的ID，还有ATID表示物种的ID。让文档里所有的东西都有一个关键字是一个好主意。</p>
<p>为了简洁起见，我已经省略了所有API共有的URL前缀。作为沟通方式这没什么问题，但是如果你真要写到API文档中，那就必须包含完整的路径（如，GET <a href="http://api.example.com/v1/animal_type/ATID）。" target="_blank" rel="external">http://api.example.com/v1/animal_type/ATID）。</a></p>
<p>请注意如何展示数据之间的关系，特别是雇员与动物园之间的多对多关系。通过添加一个额外的URL段就可以实现更多的交互能力。当然没有一个HTTP动词能表示正在解雇一个人，但是你可以使用DELETE一个动物园里的雇员来达到相同的效果。</p>
<h2 id="Filtering">Filtering</h2><p>过滤器</p>
<p>When a Consumer makes a request for a listing of objects, it is important that you give them a list of every single object matching the requested criteria. This list could be massive. But, it is important that you don’t perform any arbitrary limitations of the data. It is these arbitrary limits which make it hard for a third party developer to know what is going on. If they request a certain Collection, and iterate over the results, and they never see more than 100 items, it is now their job to figure out where this limit is coming from. Is their ORM buggy and limiting items to 100? Is the network chopping up large packets?</p>
<p>Minimize the arbitrary limits imposed on Third Party Developers.</p>
<p>It is important, however, that you do offer the ability for a Consumer to specify some sort of filtering/limitation of the results. The most important reason for this is that the network activity is minimal and the Consumer gets their results back as soon as possible. The second most important reason for this is the Consumer may be lazy, and if the Server can do filtering and pagination for them, all the better. The not-so-important reason (from the Consumers perspective), yet a great benefit for the Server, is that the request will be less resource heavy.</p>
<p>Filtering is mostly useful for performing GETs on Collections of resources. Since these are GET requests, filtering information should be passed via the URL. Here are some examples of the types of filtering you could conceivably add to your API:</p>
<ul>
<li>?limit=10: Reduce the number of results returned to the Consumer (for Pagination) </li>
<li>?offset=10: Send sets of information to the Consumer (for Pagination)</li>
<li>?animal_type_id=1: Filter records which match the following condition (WHERE animal_type_id = 1) </li>
<li>?sortby=name&amp;order=asc: Sort the results based on the specified attribute (ORDER BY name ASC) </li>
</ul>
<p>Some of these filterings can be redundant with endpoint URLS. For example I previously mentioned GET /zoo/ZID/animals. This would be the same thing as GET /animals?zoo_id=ZID. Dedicated endpoints being made available to the Consumer will make their lives easier, this is especially true with requests you anticipate they will make a lot. In the documentation, mention this redundancy so that Third Party Developers aren’t left wondering if differences exist.</p>
<p>Also, this goes without saying, but whenever you perform filtering or sorting of data, make sure you white-list the columns for which the Consumer can filter and sort by. We don’t want any database errors being sent to Consumers!</p>
<p>当客户端创建了一个请求来获取一个对象列表时，很重要一点就是你要返回给他们一个符合查询条件的所有对象的列表。这个列表可能会很大。但你不能随意给返回数据的数量做限制。因为这些无谓的限制会导致第三方开发者不知道发生了什么。如果他们请求一个确切的集合并且要遍历结果，然而他们发现只拿到了100条数据。接下来他们就不得不去查找这个限制条件的出处。到底是ORM的bug导致的，还是因为网络截断了大数据包？</p>
<p>尽可能减少那些会影响到第三方开发者的无谓限制</p>
<p>这点很重要，但你可以让客户端自己对结果做一些具体的过滤或限制。这么做最重要的一个原因是可以最小化网络传输，并让客户端尽可能快的得到查询结果。其次是客户端可能比较懒，如果这时服务器能对结果做一些过滤或分页，对大家都是好事。另外一个不那么重要的原因是（从客户端角度来说），对服务器来说响应请求的负载越少越好。</p>
<p>过滤器是最有效的方式去处理那些获取资源集合的请求。所以只要出现GET的请求，就应该通过URL来过滤信息。以下有一些过滤器的例子，可能是你想要填加到API中的：</p>
<ul>
<li>?limit=10: 减少返回给客户端的结果数量（用于分页）</li>
<li>?offset=10: 发送一堆信息给客户端（用于分页）</li>
<li>?animal_type_id=1: 使用条件匹配来过滤记录</li>
<li>?sortby=name&amp;order=asc:  对结果按特定属性进行排序</li>
</ul>
<p>有些过滤器可能会与端点URL的效果重复。例如我之前提到的GET /zoo/ZID/animals。它也同样可以通过GET /animals?zoo_id=ZID来实现。独立的端点会让客户端更好过一些，因为他们的需求往往超出你的预期。本文中提到这种冗余差异可能对第三方开发者并不可见。</p>
<p>无论怎么说，当你准备过滤或排序数据时，你必须明确的将那些客户端可以过滤或排序的列放到白名单中，因为我们不想将任何的数据库错误发送给客户端。</p>
<h2 id="Status_Codes">Status Codes</h2><p>状态码</p>
<p>It is very important that as a RESTful API, you make use of the proper HTTP Status Codes; they are a standard after all! Various network equipment is able to read these status codes, e.g. load balancers can be configured to avoid sending requests to a web server sending out lots of 50x errors. There are a plethora of HTTP Status Codes to choose from, however this list should be a good starting point:</p>
<p>对于一个RESTful API来说很重要的一点就是要使用HTTP的状态码，因为它们是HTTP的标准。很多的网络设备都可以识别这些状态码，例如负载均衡器可能会通过配置来避免发送请求到一台web服务器，如果这台服务器已经发送了很多的50x错误回来。这里有大量的HTTP状态码可以选择，但是下面的列表只给出了一些重要的代码作为一个参考：</p>
<ul>
<li>200 OK – [GET]<ul>
<li>The Consumer requested data from the Server, and the Server found it for them (Idempotent)</li>
<li>客户端向服务器请求数据，服务器成功找到它们</li>
</ul>
</li>
<li>201 CREATED – [POST/PUT/PATCH]<ul>
<li>The Consumer gave the Server data, and the Server created a resource</li>
<li>客户端向服务器提供数据，服务器根据要求创建了一个资源</li>
</ul>
</li>
<li>204 NO CONTENT – [DELETE]<ul>
<li>The Consumer asked the Server to delete a Resource, and the Server deleted it</li>
<li>客户端要求服务器删除一个资源，服务器删除成功</li>
</ul>
</li>
<li>400 INVALID REQUEST – [POST/PUT/PATCH]<ul>
<li>The Consumer gave bad data to the Server, and the Server did nothing with it (Idempotent)</li>
<li>客户端向服务器提供了不正确的数据，服务器什么也没做</li>
</ul>
</li>
<li>404 NOT FOUND – [*]<ul>
<li>The Consumer referenced an inexistant Resource or Collection, and the Server did nothing (Idempotent)</li>
<li>客户端引用了一个不存在的资源或集合，服务器什么也没做</li>
</ul>
</li>
<li>500 INTERNAL SERVER ERROR – [*]<ul>
<li>The Server encountered an error, and the Consumer has no knowledge if the request was successful</li>
<li>服务器发生内部错误，客户端无法得知结果，即便请求已经处理成功</li>
</ul>
</li>
</ul>
<h2 id="Status_Code_Ranges">Status Code Ranges</h2><p>状态码范围</p>
<ul>
<li><p>The 1xx range is reserved for low-level HTTP stuff, and you’ll very likely go your entire career without manually sending one of these status codes.</p>
</li>
<li><p>The 2xx range is reserved for successful messages where all goes as planned. Do your best to ensure your Server sends as many of these to the Consumer as possible.</p>
</li>
<li><p>The 3xx range is reserved for traffic redirection. Most APIs do not use these requests much (not nearly as often as the SEO folks use them ;), however, the newer Hypermedia style APIs will make more use of these.</p>
</li>
<li><p>The 4xx range is reserved for responding to errors made by the Consumer, e.g. they’re providing bad data or asking for things which don’t exist. These requests should be be idempotent, and not change the state of the server.</p>
</li>
<li><p>The 5xx range is reserved as a response when the Server makes a mistake. Often times, these errors are thrown by low-level functions even outside of the developers hands, to ensure a Consumer gets some sort of response. The Consumer can’t possibly know the state of the server when a 5xx response is received, and so these should be avoidable.</p>
</li>
<li><p>1xx范围的状态码是保留给底层HTTP功能使用的，并且估计在你的职业生涯里面也用不着手动发送这样一个状态码出来。</p>
</li>
<li><p>2xx范围的状态码是保留给成功消息使用的，你尽可能的确保服务器总发送这些状态码给用户。</p>
</li>
<li><p>3xx范围的状态码是保留给重定向用的。大多数的API不会太常使用这类状态码，但是在新的超媒体样式的API中会使用更多一些。</p>
</li>
<li><p>4xx范围的状态码是保留给客户端错误用的。例如，客户端提供了一些错误的数据或请求了不存在的内容。这些请求应该是幂等的，不会改变任何服务器的状态。</p>
</li>
<li><p>5xx范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，并且开发人员也通常没法处理。发送这类状态码的目的是确保客户端能得到一些响应。收到5xx响应后，客户端没办法知道服务器端的状态，所以这类状态码是要尽可能的避免。</p>
</li>
</ul>
<h2 id="Expected_Return_Documents">Expected Return Documents</h2><p>预期的返回文档</p>
<p>When performing actions using the different HTTP verbs to Server endpoints, a Consumer needs to get some sort of information in return. This list is pretty typical of RESTful APIs:</p>
<ul>
<li>GET /collection: Return a listing (array) of Resource objects</li>
<li>GET /collection/resource: Return an individual Resource object</li>
<li>POST /collection: Return the newly created Resource object</li>
<li>PUT /collection/resource: Return the complete Resource object</li>
<li>PATCH /collection/resource: Return the complete Resource object</li>
<li>DELETE /collection/resource: Return an empty document</li>
</ul>
<p>Note that when a Consumer creates a Resource, they usually do not know the ID of the Resource being created (nor other attributes such as created and modified timestamps, if applicable). These additional attributes are returned with subsequent request, and of course as a response to the initial POST.</p>
<p>当使用不同的HTTP动词向服务器请求时，客户端需要在返回结果里面拿到一系列的信息。下面的列表是非常经典的RESTful API定义：</p>
<ul>
<li>GET /collection: 返回一系列资源对象</li>
<li>GET /collection/resource: 返回单独的资源对象</li>
<li>POST /collection: 返回新创建的资源对象</li>
<li>PUT /collection/resource: 返回完整的资源对象</li>
<li>PATCH /collection/resource: 返回完整的资源对象</li>
<li>DELETE /collection/resource: 返回一个空文档</li>
</ul>
<p>请注意当一个客户端创建一个资源时，她们常常不知道新建资源的ID（也许还有其他的属性，如创建和修改的时间戳等）。这些属性将在随后的请求中返回，并且作为刚才POST请求的一个响应结果。</p>
<h2 id="Authentication">Authentication</h2><p>认证</p>
<p>Most of the time a Server will want to know exactly who is making which Requests. Sure, some APIs provide endpoints to be consumed by the general (anonymous) public, but most of the time work is being perform on behalf of someone.</p>
<p>OAuth 2.0 provides a great way of doing this. With each Request, you can be sure you know which Consumer is making requests, which User they are making requests on behalf of, and provides a (mostly) standardized way of expiring access or allowing Users to revoke access from a Consumer, all without the need for a third-party consumer to know the Users login credentials.</p>
<p>There are also OAuth 1.0 and xAuth, which fill the same space. Whichever method you choose, make sure it is something common and well documented with many different libraries written for the languages/platforms which your Consumers will likely be using.</p>
<p>I can honestly tell you that OAuth 1.0a, while it is the most secure of the options, is a huge pain in the ass to implement. I was surprised by the number of Third Party Developers who had to implement their own library since one didn’t exist for their language already. I’ve spent enough hours debugging cryptic “invalid signature” errors to recommend you choose an alternative.</p>
<p>服务器在大多数情况下是想确切的知道谁创建了什么请求。当然，有些API是提供给公共用户（匿名用户）的，但是大部分时间里也是代表某人的利益。</p>
<p>OAuth2.0提供了一个非常好的方法去做这件事。在每一个请求里，你可以明确知道哪个客户端创建了请求，哪个用户提交了请求，并且提供了一种标准的访问过期机制或允许用户从客户端注销，所有这些都不需要第三方的客户端知道用户的登陆认证信息。</p>
<p>还有OAuth1.0和xAuth同样适用这样的场景。无论你选择哪个方法，请确保它为多种不同语言/平台上的库提供了一些通用的并且设计良好文档，因为你的用户可能会使用这些语言和平台来编写客户端。</p>
<h2 id="Content_Type">Content Type</h2><p>内容类型</p>
<p>Currently, the most “exciting” of APIs provide JSON data from RESTful interfaces. This includes Facebook, Twitter, GitHub, you name it. XML appears to have lost the war a while ago (except in large corporate environments). SOAP, thankfully, is all but dead, and we really don’t see much APIs providing HTML to be consumed (unless, that is, you’re building a scraper!)</p>
<p>Developers using popular languages and frameworks can very likely parse any valid data format you return to them. You can even provide data in any of the aforementioned data formats (not including SOAP) quite easily, if you’re building a common response object and using a different serializer. What does matter though, is that you make use of the Accept header when responding with data.</p>
<p>Some API creators recommend adding a .json, .xml, or .html file extension to the URL (after the endpoint) for specifying the content type to be returned, although I’m personally not a fan of this. I really like the Accept header (which is built into the HTTP spec) and feel that is the appropriate thing to use.</p>
<p>目前，大多数“精彩”的API都为RESTful接口提供JSON数据。诸如Facebook，Twitter，Github等等你所知的。XML曾经也火过一把（通常在一个大企业级环境下）。这要感谢SOAP，不过它已经挂了，并且我们也没看到太多的API把HTML作为结果返回给客户端（除非你在构建一个爬虫程序）。</p>
<p>只要你返回给他们有效的数据格式，开发者就可以使用流行的语言和框架进行解析。如果你正在构建一个通用的响应对象，通过使用一个不同的序列化器，你也可以很容易的提供之前所提到的那些数据格式（不包括SOAP）。而你所要做的就是把使用方式放在响应数据的接收头里面。</p>
<p>有些API的创建者会推荐把.json, .xml, .html等文件的扩展名放在URL里面来指示返回内容类型，但我个人并不习惯这么做。我依然喜欢通过接收头来指示返回内容类型（这也是HTTP标准的一部分），并且我觉得这么做也比较适当一些。</p>
<h2 id="Hypermedia_APIs">Hypermedia APIs</h2><p>超媒体API</p>
<p>Hypermedia APIs are very likely the future of RESTful API design. They’re actually a pretty amazing concept, going “back to the roots” of how HTTP and HTML was intended to work.</p>
<p>When working with non-Hypermedia RESTful APIs, the URL Endpoints are part of the contract between the Server and the Consumer. These Endpoints MUST be known by the Consumer ahead of time, and changing them means the Consumer is no longer able to communicate with the Server as intended. This, as you can assume, is quite a limitation.</p>
<p>Now, API Consumers are of course not the only user agent making HTTP requests on the Internet. Far from it. Humans, with their web browsers, are the most common user agent making HTTP requests. Humans, however, are NOT locked into this predefined Endpoint URL contract that RESTful APIs are. What makes humans so special? Well, they’re able to read content, click links for headings which look interesting, and in general explore a website and interpret content to get to where they want to go. If a URL changes, a human is not affected (unless, that is, they bookmarked a page, in which case they go to the homepage and find a new route to their beloved data).</p>
<p>The Hypermedia API concept works the same way a human would. Requesting the Root of the API returns a listing of URLs which point perhaps to each collection of information, and describing each collection in a way which the Consumer can understand. Providing IDs for each resource isn’t important (or necessarily required), as long as a URL is provided.</p>
<p>With the Consumer of a Hypermedia API crawling links and gathering information, URLs are always up-to-date within responses, and do not need to be known beforehand as part of a contract. If a URL is ever cached, and a subsequent request returns a 404, the Consumer can simply go back to the root and discover the content again.</p>
<p>When retrieving a list of Resources within a Collection, an attribute containing a complete URL for the individual Resources are returned. When performing a POST/PATCH/PUT, the response can be a 3xx redirect to the complete Resource.</p>
<p>JSON doesn’t quite give us the semantics we need for specifying which attributes are URLs, nor how URLs relate to the current document. HTML, as you can probably guess, does provide this information. We may very well see our APIs coming full circle and returning back to consuming HTML. Considering how far we’ve come with CSS, one day we may even see  it be common practice for APIs and Websites to use the exact same URLs and content.</p>
<p>超媒体API很可能就是RESTful API设计的将来。超媒体是一个非常棒的概念，它回归到了HTTP和HTML如何运作的“本质”。</p>
<p>在非超媒体RESTful API的情景中，URL端点是服务器与客户端契约的一部分。这些端点必须让客户端事先知道，并且修改它们也意味着客户端可能再也无法与服务器通信了。你可以先假定这是一个限制。</p>
<p>时至今日，英特网上的API客户端已经不仅仅只有那些创建HTTP请求的用户代理了。大多数HTTP请求是由人们通过浏览器产生的。人们不会被哪些预先定义好的RESTful API端点URL所束缚。是什么让人们变的如此与众不同？因为人们可以阅读内容，可以点击他们感兴趣的链接，并浏览一下网站，然后跳到他们关注的内容那里。即使一个URL改变了，人们也不会受到影响（除非他们事先给某个页面做了书签，这时他们回到主页并发现原来有一条新的路径可以去往之前的页面）。</p>
<p>超媒体API概念的运作跟人们的行为类似。通过请求API的根来获得一个URL的列表，这个列表里面的每一个URL都指向一个集合，并且提供了客户端可以理解的信息来描述每一个集合。是否为每一个资源提供ID并不重要（或者不是必须的），只要提供URL即可。</p>
<p>一个超媒体API一旦具有了客户端，那么它就可以爬行链接并收集信息，而URL总是在响应中被更新，并且不需要如契约的一部分那样事先被知晓。如果一个URL曾经被缓存过，并且在随后的请求中返回404错误，那么客户端可以很简单的回退到根URL并重新发现内容。</p>
<p>在获取集合中的一个资源列表时会返回一个属性，这个属性包含了各个资源的完整URL。当实施一个POST/PATCH/PUT请求后，响应可以被一个3xx的状态码重定向到完整的资源上。</p>
<p>JSON不仅告诉了我们需要定义哪些属性作为URL，也告诉了我们如何将URL与当前文档关联的语义。正如你猜的那样，HTML就提供了这样的信息。我们可能很乐意看到我们的API走完了完整的周期，并回到了处理HTML上来。想一下我们与CSS一起前行了多远，有一天我们可能再次看到它变成了一个通用实践让API和网站可以去使用相同的URL和内容。</p>
<h2 id="Documentation">Documentation</h2><p>文档</p>
<p>Honestly, if you don’t conform 100% to the criteria in this guide, your API will not necessarily be horrible. However, if you don’t properly document your API, nobody is going to know how to use it, and it WILL be a horrible API.</p>
<p>Make your Documentation available to unauthenticated developers.</p>
<p>Do not use automatic documentation generators, or if you do, at least make sure you’re doctoring it up and making it presentable.</p>
<p>Do not truncate example request and response bodies; show the whole thing. Use a syntax highlighter in your documentation.</p>
<p>Document expected response codes and possible error messages for each endpoint, and what could have gone wrong to cause those error messages.</p>
<p>If you’ve got the spare time, build a developer API console so that developers can immediately experiment with your API. It’s not as hard as you might think and developers (both internal and third party) will love you for it!</p>
<p>Make sure your documentation can be printed; CSS is a powerful thing; don’t be afraid to hide that sidebar when the docs are printed. Even if nobody ever prints a physical copy, you’d be surprised at how many developers like to print to PDF for offline reading.</p>
<p>老实说，即使你不能百分之百的遵循指南中的条款，你的API也不是那么糟糕。但是，如果你不为API准备文档的话，没有人会知道怎么使用它，那它真的会成为一个糟糕的API。</p>
<p>让你的文档对那些未经认证的开发者也可用<br>不要使用文档自动化生成器，即便你用了，你也要保证自己审阅过并让它具有更好的版式。<br>不要截断示例中请求与响应的内容，要展示完整的东西。并在文档中使用高亮语法。<br>文档化每一个端点所预期的响应代码和可能的错误消息，和在什么情况下会产生这些的错误消息<br>如果你有富余的时间，那就创建一个控制台来让开发者可以立即体验一下API的功能。创建一个控制台并没有想象中那么难，并且开发者们（内部或者第三方）也会因此而拥戴你。</p>
<p>另外确保你的文档能够被打印。CSS是个强大的工具可以帮助到你。而且在打印的时候也不用太担心边侧栏的问题。即便没有人会打印到纸上，你也会惊奇的发现很多开发者愿意转化成PDF格式进行离线阅读。</p>
<h2 id="Errata:_Raw_HTTP_Packet">Errata: Raw HTTP Packet</h2><p>勘误：原始的HTTP封包</p>
<p>Since everything we do is over HTTP, I’m going to show you a dissection of an HTTP packet. I’m often surprised at how many people don’t know what these things look like! When the Consumer sends a Request to the Server, they provide a set of Key/Value pairs, called a Header, along with two newline characters, and finally the request body. This is all sent in the same packet.</p>
<p>The server then responds in the say Key/Value pair format, with two newlines and then the response body. HTTP is very much a request/response protocol; there is no “Push” support (the Server sending data to the Consumer unprovoked), unless you use a different protocol such as Websockets.</p>
<p>When designing your API, you should be able to work with tools which allow you to look at raw HTTP packets. Consider using Wireshark, for example. Also, make sure you are using a framework / web server which allows you to read and change as many of these fields as possible.</p>
<p>因为我们所做的都是基于HTTP协议，所以我将展示给你一个解析了的HTTP封包。我经常很惊讶的发现有多少人不知道这些东西。当客户端发送一个请求道服务器时，他们会提供一个键值对集，先是一个头，紧跟着是两个回车换行符，然后才是请求体。所有这些都是在一个封包里被发送。</p>
<p>服务器响应也是同样的键值对集，带两个回车换行符，然后是响应体。HTTP就是一个请求/响应协议；它不支持“推送”模式（服务器直接发送数据给客户端），除非你采用其他协议，如Websockets。</p>
<p>当你设计API时，你应该能够使用工具去查看原始的HTTP封包。Wireshark是个不错的选择。同时，你也该采用一个框架/web服务器，使你能够在必要时修改某些字段的值。</p>
<p><em>Example HTTP Request</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Wed, <span class="number">18</span> Dec <span class="number">2013</span> <span class="number">06</span>:<span class="number">08</span>:<span class="number">22</span> GMT</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span></span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">"created"</span>: <span class="number">1386363036</span>,</span><br><span class="line">  <span class="string">"modified"</span>: <span class="number">1386363036</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Gir"</span>,</span><br><span class="line">  <span class="string">"animal_type"</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/API/" rel="tag">#API</a>
          
            <a href="/tags/RESTful/" rel="tag">#RESTful</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Principle-and-implementation-of-AES/" rel="next" title="AES加密原理与实现">
                <i class="fa fa-chevron-left"></i> AES加密原理与实现
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="design-a-RESTful-API/"
           data-title="好RESTful API的设计原则" data-url="http://www.wxameng.com/design-a-RESTful-API/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="阿蒙" />
          <p class="site-author-name" itemprop="name">阿蒙</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lonelylwm" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/lonelyawm" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">友情链接</p>
            
              <span class="links-of-author-item">
                <a href="http://www.intelligentunit.com" target="_blank">智能单元</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://songrotek.github.io" target="_blank">songrotek</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简版_RESTful"><span class="nav-number">1.</span> <span class="nav-text">简版 RESTful</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议"><span class="nav-number">1.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域名"><span class="nav-number">1.2.</span> <span class="nav-text">域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本（Versioning）"><span class="nav-number">1.3.</span> <span class="nav-text">版本（Versioning）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径（Endpoint）"><span class="nav-number">1.4.</span> <span class="nav-text">路径（Endpoint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP动词"><span class="nav-number">1.5.</span> <span class="nav-text">HTTP动词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤信息（Filtering）"><span class="nav-number">1.6.</span> <span class="nav-text">过滤信息（Filtering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态码（Status_Codes）"><span class="nav-number">1.7.</span> <span class="nav-text">状态码（Status Codes）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理（Error_handling）"><span class="nav-number">1.8.</span> <span class="nav-text">错误处理（Error handling）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回结果"><span class="nav-number">1.9.</span> <span class="nav-text">返回结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hypermedia_API"><span class="nav-number">1.10.</span> <span class="nav-text">Hypermedia API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">1.11.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全文版_RESTful"><span class="nav-number">2.</span> <span class="nav-text">全文版 RESTful</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Definitions"><span class="nav-number">3.</span> <span class="nav-text">Definitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data_Design_and_Abstraction"><span class="nav-number">4.</span> <span class="nav-text">Data Design and Abstraction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Verbs"><span class="nav-number">5.</span> <span class="nav-text">Verbs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Versioning"><span class="nav-number">6.</span> <span class="nav-text">Versioning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Analytics"><span class="nav-number">7.</span> <span class="nav-text">Analytics</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API_Root_URL"><span class="nav-number">8.</span> <span class="nav-text">API Root URL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Endpoints"><span class="nav-number">9.</span> <span class="nav-text">Endpoints</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filtering"><span class="nav-number">10.</span> <span class="nav-text">Filtering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Status_Codes"><span class="nav-number">11.</span> <span class="nav-text">Status Codes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Status_Code_Ranges"><span class="nav-number">12.</span> <span class="nav-text">Status Code Ranges</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Expected_Return_Documents"><span class="nav-number">13.</span> <span class="nav-text">Expected Return Documents</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Authentication"><span class="nav-number">14.</span> <span class="nav-text">Authentication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Content_Type"><span class="nav-number">15.</span> <span class="nav-text">Content Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hypermedia_APIs"><span class="nav-number">16.</span> <span class="nav-text">Hypermedia APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Documentation"><span class="nav-number">17.</span> <span class="nav-text">Documentation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Errata:_Raw_HTTP_Packet"><span class="nav-number">18.</span> <span class="nav-text">Errata: Raw HTTP Packet</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿蒙</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wxameng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  


</body>
</html>
